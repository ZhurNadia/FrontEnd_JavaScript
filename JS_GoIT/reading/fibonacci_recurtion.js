/**Задание 1 (Последовательность Фибоначчи)

 Последовательность чисел Фибоначчи вычисляется по формуле формулу F(n) = F(n-1) + F(n-2). В ней каждое следующее число
 вычисляется как сумма двух предыдущих. Первые два числа равны 1 и 1.

 Напишите функцию fib(n), которая возвращает n-е число Фибоначчи.

 Например:

 console.log(fib(3)); //2
 console.log(fib(7)); //13
 console.log(fib(77)); //5527939700884757
 */


//Эффективное решение через рекурсию, работает по скорости так же, как и через цикл:


    function fib(n, x, y) {
        if (!x) x = 0, y = 1;

        while (n > 2)
            return (x >= y) ? fib(n-1, x, x+y) : fib(n-1, x+y, y);

        return x + y;
    }

alert(fib(77));


//Вычисление рекурсией (медленное)

//Решение по формуле, используя рекурсию:

function fib(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // не запускаем, подвесит браузер
/**При больших значениях n оно будет работать очень медленно. Например, fib(77) уже будет вычисляться очень долго.

 Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:
 ...
 fib(5) = fib(4) + fib(3)
 fib(4) = fib(3) + fib(2)
 ...
 Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено два раза,
 совершенно независимо.

 Можно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант —
 вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений 1, 2, затем из них получить fib(3), далее fib(4), затем fib(5) и так далее, до нужного значения.

 Это решение будет наиболее эффективным. Попробуйте его написать.

 Алгоритм вычисления в цикле

 Будем идти по формуле слева-направо:

 var a = 1, b = 1; // начальные значения
 var c = a + b; // 2

 /* переменные на начальном шаге:
 a  b  c
 1, 1, 2
 */
//Теперь следующий шаг, присвоим a и b текущие 2 числа и получим новое следующее в c:

a = b, b = c;
c = a + b;

/** стало так (ещё число):
 a  b  c
 1, 1, 2, 3
 */
//Следующий шаг даст нам ещё одно число последовательности:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
 a  b  c
 1, 1, 2, 3, 5
 */
/**Повторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.

 P.S. Этот подход к вычислению называется динамическое программирование снизу-вверх.

 Код для вычисления в цикле
 */

function fib(n) {
    var a = 1,
        b = 1;
    for (var i = 3; i <= n; i++) {
        var c = a + b;
        a = b;
        b = c;
    }
    return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757

//Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.


//или вариант
alert(fib(+prompt('Которое число Фибоначчи хотите увидеть?')));


function fib(n) {
    var f, t1, t2;

    for (i = 1; i <= n; i++) {
        f = t1 + t2 || 1;
        t1 = t2;
        t2 = f;
    }
    return f;
}

//c массивами
//Рекурсивная функция для вычисления чисел Фибоначчи с запоминанием вычисленных значений.
// Не совсем конечно красиво, что массив fibStore находится вне функции, но тем не менее.

    var fibStore = [0, 1];
function optimizedFib(n) {
    if (typeof fibStore[n - 1] === 'undefined') {
        fibStore[n - 1] = optimizedFib(n - 1);
    }
    if (typeof fibStore[n - 2] === 'undefined') {
        fibStore[n - 2] = optimizedFib(n - 2);
    }
    return fibStore[n - 1] + fibStore[n - 2];
}
console.log( 'Рекурсивная функция (оптимизированная):' );
console.log( optimizedFib(3) ); // 2
console.log( optimizedFib(7) ); // 13
console.log( optimizedFib(77)); // 5527939700884757


// Фибоначчи (для z принадлежащих Z). Вроде, вписался в требование (комментарий до 10 строк :) ).
function fib(z) {
    var fn_2 = 0, fn_1 = 1, n = z > 0 ? z : -z;
    for (var i = 2; i <= n; i++) {
        fn = fn_1 + fn_2;
        fn_2 = fn_1; fn_1 = fn;
    }
    var fn = n > 1 ? fn : n;
    return z > 0 || n % 2 ? fn : -fn;
}

// Цикл:
function sumTo(n) {
    var sum = 0;
    do sum += n--; while (n);
    return sum;
}


// Рекурсия:
function sumTo(n) { return n && n + sumTo(--n) }
// Прогрессия:
function sumTo(n) { return n * ++n >> 1 }


//еще одно решение
function fib(n, f0=0, f1=1) {
    if(n > 1)
        return fib(--n, f1, f0 + f1);
    else if(n < -1)
        return fib(++n, f1, f0 - f1);
    else if(n == 0)
        return n;
    else
        return f1;
}

alert('fib(3) = ' + fib(3));
alert('fib(7) = ' + fib(7));
alert('fib(77) = ' + fib(77));

alert('fib(0) = ' + fib(0));

alert('fib(-3) = ' + fib(-3));
alert('fib(-8) = ' + fib(-8));
alert('fib(-77) = ' + fib(-77));


//Мой вариант Фибоначчи. ^^

function fib(n){
    function fibNow(a,b,m){
        console.log(a,b,m);
        if (n==1 || n==2)
            return 1;
        if (m==n)
            return a+b;
        else{
            var c=a;
            a=b;
            b=b+c;
            m+=1;
            return fibNow(a,b,m);
        }
    }
    return fibNow(1,1,3);
}

/**
Небольшое уточнение: в Wiki последовательность Фибоначчи начинается от 0, т.е. 0, 1, 1, 2, 3, 5, 8, 13...,
 а не 1, 1, 2, 3, 5, 8, 13 - как сказано в условии задачи. Другими словами, значение третьего члена должно быть
 1, а не 2, ну и так далее.
    Для последовательности от нуля рекурсию переписал вот так:
 */

    function fib(n) {
        return (n <= 2) ? n - 1 : fib(n - 1) + fib(n - 2)
    }// fib
а цикл вот так:

    function fib(n) {
        n1 = 0;
        n2 = 1;
        for (var i = 3; i <= n; i++) {
            result = n1 + n2;
            n1 = n2;
            n2 = result;
        }// for i
        return (n <= 2) ? n - 1 : result;
    }// fib